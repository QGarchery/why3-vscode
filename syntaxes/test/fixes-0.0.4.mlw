let  ref foo = 2

val tortoise_and_hare (c, d: int) (a: int, b : int) : (mu:int, lambda:int) 

val ([]<-) (m: t 'a) (k: int, d: key) (v: 'a): unit

let replace (m : ref rbt) k v
= let (d, t) = !m in
  m := (d, add t k v)

if sum > !maxsum then begin
  maxsum := sum;
  rlo := rl; rhi := rh;
  clo := lo; chi := hi
end

let tortoise_and_hare (c : int) : my_type = 
  [@vc:do_not_keep_trace] (* traceability info breaks the proofs *)
  let mu, lambda = periodicity () in
  equality mu lambda

axiom OneClass :
  forall a u : uf_pure.
  num u = 1 ->
  forall x, y:int. 0 <= x < size u -> 0 <= y < size u -> same u x y

type non_det = abstract { mutable non_det_field : non_det_magic }

type foo = {
  mutable bar1: int; (* simple comment *)
  mutable bar2: float; 
}

type foo = { mutable bar: int }

type foo = {
   mutable bar: int; (* not ghost, not ghost mutable *)
}

lemma preds_def: forall g:graph, truc: machin. forall v:vertex. forall u:vertex.
  S.mem (u,v) (edges g) <-> S.mem u (preds g v)

use mach.int.Int63

let r' = sqrt r (2.0 * eps) (Int.(*) 2 n) eps0 in
  if (r' + eps) * (r' + eps) <= r then r' + eps else r'
