let  ref foo = 2

val tortoise_and_hare (c, d: int) (a: int, b : int) : (mu:int, lambda:int) 

val ([]<-) (m: t 'a) (k: int, d: key) (v: 'a): unit

let replace (m : ref rbt) k v
= let (d, t) = !m in
  m := (d, add t k v)

if sum > !maxsum then begin
  maxsum := sum;
  rlo := rl; rhi := rh;
  clo := lo; chi := hi
end

let tortoise_and_hare (c : int) : my_type = 
  [@vc:do_not_keep_trace] (* traceability info breaks the proofs *)
  let mu, lambda = periodicity () in
  equality mu lambda

axiom OneClass :
  forall a u : uf_pure.
  num u = 1 ->
  forall x, y:int. 0 <= x < size u -> 0 <= y < size u -> same u x y

type non_det = abstract { mutable non_det_field : non_det_magic }

type foo = {
  mutable bar1: int; (* simple comment *)
  mutable bar2: float; 
}

type foo = { mutable bar: int }

type foo = {
   mutable bar: int; (* not ghost, not ghost mutable *)
}
