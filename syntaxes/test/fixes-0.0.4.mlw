(* Finally, we implement the tortoise and hare algorithm that computes
    the values of mu and lambda in time O(mu+lambda) and constant space *)
let tortoise_and_hare () : (mu:int, lambda:int)
  ensures { 0 <= mu < m /\ 1 <= lambda <= m /\ mu + lambda <= m /\
            x (mu + lambda) = x mu }
  ensures { forall i j. 0 <= i < j < mu + lambda -> x i <> x j }
= [@vc:do_not_keep_trace] (* traceability info breaks the proofs *)
  let mu, lambda = periodicity () in
  equality mu lambda;

axiom OneClass :
  forall u:uf_pure. num u = 1 ->
  forall x y:int. 0 <= x < size u -> 0 <= y < size u -> same u x y

let replace (m : ref rbt) k v
  requires { inv !m }
  ensures { inv !m /\
    default !m = default (old !m) /\
    forall k':key, v':value.
    mem !m k' v' <-> if k' = k then v' = v else mem (old !m) k' v' }
= let (d, t) = !m in
  m := (d, add t k v)

type non_det = abstract { mutable non_det_field : non_det_magic }

if sum > !maxsum then begin
  maxsum := sum;
  rlo := rl; rhi := rh;
  clo := lo; chi := hi
end

type foo = {
  mutable bar1: int; (* simple comment *);
  mutable bar2: float; 
}

type foo = { mutable bar: int }

type foo = {
   mutable bar: int; (* not ghost, not ghost mutable *)
}
