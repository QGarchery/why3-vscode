(* Finally, we implement the tortoise and hare algorithm that computes
    the values of mu and lambda in time O(mu+lambda) and constant space *)
let tortoise_and_hare () : (mu:int, lambda:int)
  ensures { 0 <= mu < m /\ 1 <= lambda <= m /\ mu + lambda <= m /\
            x (mu + lambda) = x mu }
  ensures { forall i j. 0 <= i < j < mu + lambda -> x i <> x j }
= [@vc:do_not_keep_trace] (* traceability info breaks the proofs *)
  let mu, lambda = periodicity () in
  equality mu lambda;

axiom OneClass :
  forall u:uf_pure. num u = 1 ->
  forall x y:int. 0 <= x < size u -> 0 <= y < size u -> same u x y

let replace (m : ref rbt) k v
  requires { inv !m }
  ensures { inv !m /\
    default !m = default (old !m) /\
    forall k':key, v':value.
    mem !m k' v' <-> if k' = k then v' = v else mem (old !m) k' v' }
= let (d, t) = !m in
  m := (d, add t k v)

type non_det = abstract { mutable non_det_field : non_det_magic }

if sum > !maxsum then begin
  maxsum := sum;
  rlo := rl; rhi := rh;
  clo := lo; chi := hi
end

predicate machin'unus_123ed (lbidule : azemlk) : truc
predicate machin bid'_123'ule (bidule': er) : Fset.mem truc = if true then false

let tower_of_hanoi (a b c: tower)
  requires { b.rod = c.rod = Nil }
  ensures  { b.rod = old a.rod }
  ensures  { a.rod = c.rod = Nil }
= hanoi_rec a b c (length a.rod) (ghost rev_append a.rod Nil) Nil

axiom preds_def: forall g:graph, truc: machin. forall v:vertex. forall u:vertex.
  S.mem (u,v) (edges g) <-> S.mem u (preds g v)

module Online_basic

  use ref.Ref
  use Online_graph'
  use set.Fset
  use export Graph
end

let rec u = ref mach in ref 0

val ghost function defined_sort (m: t int): Fset.fset vertex
  ensures { forall v: vertex [Fset.mem v result], g : vertex.sdlf. sdf qsd.
            Fset.mem v result <-> 0 <= m[v] }

val ([]<-) (m: t 'a) (k: key) (v: 'a): unit
  writes { m }
  ensures { m = (old m)[k <- v] }

